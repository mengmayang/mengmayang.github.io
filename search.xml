<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dataTableMove]]></title>
    <url>%2F2018%2F10%2F30%2FdataTableMove%2FdataTableMove%2F</url>
    <content type="text"><![CDATA[dataTableMove 表格拖动插件表格界插件dataTable基于jquery构造，在angular 1 中的经常会有冲突的现象。由于angular项目中需要一个表格实现类似的功能：首行固定，左右拖动时前n列固定，上下拖动时，只有首行固定。为了实现这个功能，我写了生平第一个小插件dataTableMove：https://github.com/mengmayang/dataTableMove 实现效果为 https://mengmayang.github.io/dataTableMove/dataTableMove.html 虽然实现功能比较少，但还是很激动的。稍微体会了一下程序员创造世界的快乐。 使用方法HTML 文件中需要有三个div，其中id为tableId的在divId内部，并且需要在文档尾部加载dataTableMove_v2.js，调用方法很简单，colFixedNum指定固定前面多少列，然后调用dataTableMove函数，dataTableMove(“divTable”,”mytable”,width,height,top,left,colFixedNum); 123456789101112&lt;div id="divId"&gt; &lt;div id="tableId"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="position:relative;clear:both;"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="dataTableMove_v2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; colFixedNum=2; dataTableMove("divTable","mytable",600,300,120,70,colFixedNum); &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dataTableMove]]></title>
    <url>%2F2018%2F10%2F30%2FdataTableMove%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Django后端代码学习]]></title>
    <url>%2F2018%2F08%2F10%2FDjango%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近在看管理平台的源代码，没有文档和注释的代码看起来真是酸爽。但更难过的是python做后端没接触过，还有好多不熟悉的框架和包，让我的阅读进程变得异常艰难，对于我来说好多新概念。好了，废话不多说，一个一个啃哇！ DjangoDjango是python的一个开放源代码的优秀的Web框架。 ZeroRPCZeroRPC是python的一个包，在介绍它之前，首先介绍一下RPC远程过程调用。简单讲就是本地计算机调用远程计算机上的一个函数。 一个电脑程序触发远程计算机上的子程序的运行，和在本地调用方法一样，不需要程序员单独写与远程计算机交户的代码。即，无论子例程执行程序的本地代码还是远程代码，程序员编写的代码是相同的。这是一种客户机-服务器交互形式（调用者是客户机，执行者是服务器），通常通过请求-响应消息的传递方式实现。RPC是一种进程间通信（inter-process communication，IPC），因为不同进程有不同的地址空间。如果在同一主机上，它们即使物理地址空间相同，也会有不同的虚拟地址空间，如果位于不同的主机上，则物理地址空间是不同的。 Django搭建的系统需要找支持python的rpc服务。比较优秀的服务有SimpleXMLRPCServer和zerorpc。 zerorpc的底层使用ZeroMQ和MessagePack，速度快，响应时间短，并发度高。 在后端写代码时，会同时写server服务端和client客户端的代码，server上定义一些类和函数，然后通过.bind绑定url，client通过.connect来连接server绑定的url从而实现调用server里定义的类和函数。 ConfigParser该模块可以将配置文件转化成对象，读配置文件，返回section，option对应的值。 配置文件sample.ini： [book] title:ConfigParser模块教程 time:2018-08-10 09:46:55 [size] size:1024 [other] blog:csdn.net book，size，other都是section；title，time，size，blog都属于option 配置文件转化： import ConfigParser import string config=ConfigParser.ConfigParser() config.read(u&apos;sample.ini&apos;) print config.get(&quot;size&quot;,&quot;size&quot;) #输出结果为1024 SQLAlchemy数据表是一个二维表，把一个表的内容用python的数据结构表示，可以用一个list表示多行，每一个list元素是一个tuple元组。但是这样很难看出表结构，所以把一个tuple用class实例来表示，可以更容易的看出表结构，这是ORM技术，Object-Relational Mapping，把关系数据库表结构映射到对象上。在Python中，这个转换实现方法最有名的框架是SQLAlchemy。 SQLAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简言之便是：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果. 第一步，导入SQLAlchemy并初始化DBSession # 导入: from sqlalchemy import Column, String, create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.ext.declarative import declarative_base # 创建对象的基类: Base = declarative_base() # 定义User对象: class User(Base): # 表的名字: __tablename__ = &apos;user&apos; # 表的结构: id = Column(String(20), primary_key=True) name = Column(String(20)) # 初始化数据库连接: engine = create_engine(&apos;mysql+mysqlconnector://root:password@localhost:3306/test&apos;) # 创建DBSession类型: DBSession = sessionmaker(bind=engine) Session： 数据库的Session主要目的是建立与数据库的会话，维护你加载和关联的数据库对象，是数据库查询的一个入口。在SQLAlchemy中，数据库的查询操作是通过查询query对象来实现。Session提供了创建Query对象的接口。 Query对象返回的结果是一组同一映射对象组成的集合，机和中的一个对象，对应与数据库表中的一行，所谓同一映射，只如果两个对象ID相同，则认为他们对应的是相同的对象。 要实现数据库查询，需要建立与数据库的连接。需要用到Engine对象。一个Engine可能关联一个Session对象，也可能关联一个数据库表。 创建session from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker some_engine = create_engine(&apos;nysql://username:password@localhost/mydb?charset=utf8&apos;) session = sessionmaker(bind=some_engine) #创建一个session工厂 session = Session() #通过调用工厂方法来创建一个session对象 参数含义：dialect+driver:dialect+driver://username:password@host:port/database + “？param=xxxx”,如字符集“charset=utf8”（这是中文字符乱码的解决方案）如：engine = create_engine(“mysql+pymysql://root:oldboy@192.168.159.134:3306/day15?charset=utf8”, max_overflow=5)表示创建引擎，并在此基础上通过pymysql插件，连接数据库。同时创建数据库连接池，设置为5 create_engine支持连接池，pool_size 连接数，max_overflow 最多多几个连接，pool_recycle 连接重置周期，pool_timeout 连接超时时间 连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程使用.每一次数据访问请求都必须经历建立数据库连接、打开数据库、存取数据和关闭数据库连接等步骤，而连接并打开数据库是一件既消耗资源又费时的工作，如果频繁发生这种数据库操作，系统的性能必然会急剧下降，甚至会导致系统崩溃。数据库连接池技术是解决这个问题最常用的方法。 数据库连接池的主要操作如下：（1）建立数据库连接池对象（服务器启动）。（2）按照事先指定的参数创建初始数量的数据库连接（即：空闲连接数）。（3）对于一个数据库访问请求，直接从连接池中得到一个连接。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。（4）存取数据库。（5）关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。（6）释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连接）。 SQLAlchemy默认所使用的连接池为sqlalchemy.pool.QueuePool。当目前总连接数没有超过配置的上限且池中没有现成可用的连接的情况下，一个新的连接会被建立并返回给调用创建新连接的方法的程序。 session的生命周期 Session通常在我们需要对数据库进行操作时创建，一旦一个session创建成功，可以在这个session下完成多个使物，session的创建和关闭不定，但session不应该在操作事务的方法中创建 Alembic对数据库版本管理的使用方法 对于SQLALCHEMY ORM 定义的数据库，数据库的设计不一定能一步到位，在项目运行中ORM的定义model版本更改后，需要使用SQL修改数据库，当数据库结构复杂且存储数据较多时，更改起来就比较麻烦，alembic就是为了解决这个问题而产生的。通过alembic可以放心修改model中表的结构内容，数据库的具体修改交给alembic。用它实现模型类和数据库的同步更新。 代码模块化还有比较重要的就是后端代码的模块话。python类，接口，继承，需要玩的出神入化啊，涉及到具体代码，就不多说了。 配置文件这些个文件貌似我要努力看懂啊，弄懂每个含义。 参考资料：https://blog.csdn.net/hedan2013/article/details/54863830https://blog.csdn.net/yypsober/article/details/50818959https://baike.baidu.com/item/连接池/1699713?fr=aladdinhttps://blog.csdn.net/Yaokai_AssultMaster/article/details/80958052https://www.cnblogs.com/koka24/p/5327280.htmlhttps://www.cnblogs.com/yefeiyang/p/6271549.htmlhttp://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/api.html#sqlalchemy.ext.declarative.DeferredReflectionhttps://blog.csdn.net/Nero_G/article/details/53033342https://www.cnblogs.com/turingbrain/p/6372086.htmlhttp://www.runoob.com/django/django-tutorial.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>ZeroRPC</tag>
        <tag>ConfigParser</tag>
        <tag>APIView</tag>
        <tag>SQLAlchemy</tag>
        <tag>python</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RADOS]]></title>
    <url>%2F2018%2F08%2F02%2FRADOS%2F</url>
    <content type="text"><![CDATA[RADOSA Scalable, Reliable Storage Service for Petabyte-scale Storage Clusters 想了解一下Ceph的原理，没想到书上全是如何部署的教程，网上能查到的只有论文和论文译文，说实话，译文看不懂啊，有些像是机器翻译，不像人话，每当这个时候都不得不自己看原文。 读论文很痛苦，中文的也看不懂，英文的也看不懂，只能中英文一起看了。边看边增加了自己的理解。 Ceph论文阅读分三节，RADOS关于数据存储分布，CRUSH关于伪随机算法，最后一个是最重要的ceph系统。感觉回到了读研的岁月，为什么不读博的我还是要看论文？好吧，至少不用写sci了，心里还是有点安慰的~~ RADOS 想解决什么问题？在存储基础知识一中，讲到了对象存储，对象存储结合了文件存储可共享以及块存储快的优点，其设计方案是通过管理节点又叫元数据服务器（装有对象存储管理软件的服务器）来存对象的属性，可以理解为一个数据分布表-索引表，数据存在分布式服务器OSD上。用户首先访问元数据服务器，了解了数据分布情况之后再去相应的位置获取数据。此时，多台OSD同时对外传输数据，实现加速。 由此可见，OSD只是很多块通过网络连接的存储设备，客户端需要首先问管理节点数据在哪些OSD上，再访问OSD，这样的话，管理节点集群承担的任务比较中，当OSD数量成千上万时，管理节点集群的负载就吃不消了。那OSD本身能不能分担一些管理节点集群的任务呢？人们一直想将块分配策略（block allocation）和安全强制措施分布到OSD上，让OSD获得一定的智能（这边我理解的智能是类似于操作系统的调度管理，可以实现一些任务分配的自动化）从而让客户端可以直接访问OSD上的data，简化了数据分布，消除了IO瓶颈。（这边我的理解是这种智能的增加像是RAID的进化一样，在存储设备上集成一定类似于操作系统，文件系统的功能，实现数据的自动分配，减少人为设定） 所以在OSD上集成CPU,网络接口，本地缓存，基础的磁盘或者RAID（希望OSD变得更智能）。但是采用这种结构的大规模系统无法利用设备的智能，即使OSD已经具有智能分配的能力，但设备本身还是被动的执行读写命令。因此，当存储集群增长到数千节点或更多时，数据迁移的一致性管理，错误检测，错误恢复将给客户端，控制器以及元数据目录目录节点带来压力，限制可扩展性。 RADOS是一个可靠的自动的分布式对象存储，利用OSD设备本身的智能，来解决集群中存在的数据一致性访问，冗余存储，错误检测和数据恢复等问题。使得数据和负载动态地分布在不均匀的存储集群上。 存储系统是动态变化的，包括扩建，更替。设备出错和恢复都是基于连续数据的基础上，使大量数据被建立/删除。RADOS确保数据分布对系统的一致性，基于cluster map的对象读写的一致性。cluster map被复制到所有节点上，包括客户端，并被Lazy propagation的增量更新。 存储节点上有完整的数据在系统中的分布信息，使得设备可以半自治地通过类似点对点的协议来自我管理数据复制，一致和安全过程更新，参与错误检测以及响应错误和数据对象赋值迁移带来的数据分布变化。这得益于OSD本身的智能潜力，减轻了管理cluster map主副本的小型管理集群上的压力，从而使存储集群可以扩展到数千节点。 我的理解：原生对象存储是有几台管理节点，管理其他几台OSD，OSD本身并不需要智能，只是存储设备，被动的执行读写命令，关于数据迁移，错误检测等等工作都在管理节点上，所以当OSD节点非常多时，管理节点就不够用了，管理压力很大；而RADOS的方案，时OSD本身增加一些任务处理的能力，因此可以承担起原来需要在管理节点上才能完成的任务 RADOS 可扩展的集群管理RADOS系统包括大量OSD节点（包括一个CPU、一些易失性内存、一个网络接口、本地磁盘或RAID）和规模小的负责管理的monitor（有单机进程并且需要少量的本地内存 ）集合。 Cluster MapMonitor集群管理维护Cluster map。Cluster map描述了数据在系统中的分布情况。客户端提供一个简单的接口把整个存储集群虚拟成一个单一的逻辑对象存储。 在非常大的集群中，节点上千，OSD的出错和恢复都是比较平常的，因此，Cluser map的变动会很频繁。Cluster map的改变会触发map epoch的递增。Cluster map的更新以incremental maps的形式来进行分布，即用samll message来表示两个map epoch间的差异。很多更新被集中捆绑，以便描述间隔较长的map版本（看着有点像日志）。 数据的放置RADOS使用CRUSH伪随机算法，将数据伪随机地分布到设备上，当新设备增加，一个随机的现存数据的副本迁移到新设备上用以实现负载均衡。这个过程涉及到两个方面：1.计算正确的对象存储位置，2.不需要维护一个大型的集中分配表。 对象先被映射到PG组（placement group），PG组表示逻辑上的对象集合，每个对象的PG由以下公式来计算得到：pgid=(r,hash(o)&amp;m)，r表示数据主从复制的等级，hash(o)表示对象名为o的键值，m表示控制PG总数的位掩码。 PG组根据cluster map来映射到OSD节点上。每个PG被映射到有序的包含r个OSD节点的链表中。该映射通过CRUSH算法来实现（一个PG往一组设备OSD上映射）。CRUSH算法和hash算法的相似之处在于其PG值是确定的，但却是伪随机分布的；但不同的是，CRUSH是未定的，当一个或多个设备加入或离开集群时，PGs保持不变，CRUSH负责转移足够的数据来维护一个均衡的分布，HASH则更倾向于强制重新映射。 Map传播（Map Propagation）由于ODS的数据很多，所以以广播的形式来更新所有的map是不合适的。但不同的map epochs之间的差异是很明显的，所以，当两个通信的OSD（或者客户端和OSD）不同时，map才会更新。这种方式可以使得RADOS对map的更新延迟，有效地将分布的负载转移到OSD上。 OSD 智能存储设备上面我们提到了再RADOS当中，OSD拥有智能，减少了管理节点集群的负担，那么，接下来，我们就看一下OSD具体可以实现哪些任务 复制RADOS实现三种不同的复制策略： 1.Primary copy:读和写都在第一个OSD上，然后并行地更新副本到其他OSD上 2.Chain:写在第一个OSD上，读在最后一个OSD上 3.splay replication:hybrid方法，从最后一个OSD开始读，写先写在第一个OSD上，然后并行地更新副本到其他OSD上。 强一致性…是我智商有问题么？这一小段读了好久好久…本来想愉快的跳过，不知为何，强迫症逼着我非想读懂不可。 首先，RADOS中的所有信息都携带发送方的map epoch，这是前提条件。 1.如果一个发送方由于data map过期，定位到错误的OSD，该OSD会返回给它一个增量保证他更新之后重新定位到正确的OSD。 2.如果cluster map的主拷贝更新了一个特定的PG中的成员，其他老成员依然可以处理更新；如果这个更新先被一个PG副本节点接收，这个change就会被立刻发现，当住OSD转发更新消息到这个节点时，这个副本节点就会返回map增量给主OSD。因为任何一个新负责一个PG的OSD都需要与原来负责的OSD进行联系（工作交接），来保证PG内容的正确。 3.当新的OSD要负责一个PG时（工作交接），该组内所有老OSD都要被通知到，已确认自己的角色（类似于一个组换领导了，组内成员都得被通知一遍）。所以需要周期性地发送报文。这样为了保证主OSD故障时数据不可用的时间很短。（文章建议设定两秒） 内心os:真心感觉架构师不是什么人都能做的，那得是高考数学能做出最后一道大题的大神才能挑战的事情，真是方方面面事无巨细。如果data map过期怎么办？如果主拷贝map最先更新，那整体更新进展如何进行？如果副拷贝先更新，那整体更新进展如何进行？如果PG内副本OSD出现故障怎么办？如果PG内主本OSD出现故障，数据不可用，工作需要交接怎么办？呃。。。。。。好吧，大神负责create，我只能负责study了。 故障检测RADOS 采用一种异步的，有序的，点对点的消息传递方式进行通信。OSD会与自己的对端（共享同一PG data的OSD）交换周期性报文，这样，如果一个OSD出现故障，几次连接都失败后会报告给管理集群，集群将报文周期性发送，OSD发现自己被标记为down后，会同步硬盘数据，然后挂掉自己来保证系统的一致性。 数据迁移和故障恢复RADOS数据迁移和故障恢复完全是由Cluster map的更新和PG到OSD的映射驱动的。新的CRUSH策略会使所有数据重新分布。 分层复制（declustered replication）能够进行并行的故障恢复。 通过观察I/O读是否被限制来触发RADOS的recovery。 RADOS中PG的恢复由primary OSD协调，可将任何对象推送到replia OSD，保证每个拷贝对象只读一次。 MONITORS监视器Monitors是一个小的管理集群，通过春初Cluster Map的主拷贝，并周期性更新配置和OSD状态，管理整个存储系统。这个集群基于Paxos part-time parliament算法，保证数据一致性以及更新的延迟性。 monitors集群的工作负载比较小，大部分map 的分配是由OSD承担的，monitors需要承担的时候是当设备状态出现变化的时候，比如设备故障了，但是通常这种状态变化是不经常发生的。 monitors集群采用租约机制，允许任何monitor可以从OSD或Client请求Cluster map的拷贝。通常情况下，OSD很少发起更新请求，因为通常在此之前，map更新已经被共享了。而对于Client发起更新请求的情况也比较少，通常在OSD操作超时，或发生错误的时候。 对Map update的请求会被转发给Monitors集群的当前leader。Leader汇集这些请求到一个Map Update。最坏的情况下Leader的负载情况如何？当大量OSD在一个短时间内同时发生故障，比如一个OSD中放了u个PG，有f个OSD发生故障，那么，最多会有uf个错误报告。当f比较大时，消息会非常多，OSD会在伪随机时间间隔发送报文，以保证这些错误被陆续检测，压制和分别报告。非leader的monitor对一个报错转发一次，因此，leader的请求负载为fm，m为集群中monitor的数量。 我的感觉就是RADOS这个分发系统，通过OSD增加任务承担能力，减轻monitor的工作量。关键词是存储系统动态变化，集群扩建，更替，数据迁移，数据恢复。为了保证集群数据的一致性和可访问性引入Cluster map等机制，为ceph提供实现的基础。 再次内心os:读大神的论文都这么心累么？我怎么又看到了掉头发的未来。。。[/闭嘴]]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to RunningSheep’s blog! This is my first blog. I wish to use this blog to record my experience when learning the front-end knowledge and something interesting in my life.]]></content>
  </entry>
  <entry>
    <title><![CDATA[gitalk]]></title>
    <url>%2F2018%2F08%2F01%2Fgitalk%2F</url>
    <content type="text"><![CDATA[hexo + gitalk 给博客添加评论系统由于第三方评论系统基本全部扑街，所以不得不想其他对策，网上也有人提出搭建自己的第三方评论系统，但是需要自己有VPS呀，或者阿里云申请云主机？no，没钱！ 然后今天看到了gitalk，一个基于Github Issue和Preact 开发的评论插件。虽然还有一些小问题，但是从此我的博客有评论系统了，撒花~~ 详情Demo可见：https://gitalk.github.io/ 具体操作步骤如下： 1.申请github应用在GitHub上注册新应用，链接：https://github.com/settings/applications/new 参数说明：Application name： # 应用名称，随意Homepage URL： # 网站URL，如https://mengmayang.github.ioApplication description # 描述，随意Authorization callback URL：# 网站URL，https://mengmayang.github.io 然后你会得到Client ID和Client Secret 2.新增gitalk.swig新建/layout/_third-party/comments/gitalk.swig文件，并添加内容： 12345678910111213141516171819202122232425&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125; &#123;% if theme.gitalk.enable %&#125; &#123;% if theme.gitalk.distractionFreeMode %&#125; &lt;link rel=&apos;stylesheet&apos; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123;theme.gitalk.clientID&#125;&#125;&apos;, clientSecret: &apos;&#123;&#123;theme.gitalk.clientSecret&#125;&#125;&apos;, id: window.location.pathname, repo: &apos;&#123;&#123;theme.gitalk.repo&#125;&#125;&apos;, owner: &apos;&#123;&#123;theme.gitalk.owner&#125;&#125;&apos;, admin: &apos;&#123;&#123;theme.gitalk.admin&#125;&#125;&apos;, distractionFreeMode: &apos;&#123;&#123;theme.gitalk.distractionFreeMode&#125;&#125;&apos;, &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt; &#123;% endif %&#125; &#123;% endif %&#125;&#123;% endif %&#125; 3.comments.swig修改/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上： 12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; 我因为开启了disqus的count功能，所以disqus的enable是true，因此在增加gitalk的时候最后几行是： 12345678910 &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.gitalk.distractionFreeMode %&#125; &lt;div class=&quot;comments&quot; id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125; //对应整体的if，也是文件末尾 4.index.swig修改layout/_third-party/comments/index.swig，在最后一行添加内容： 12&#123;% include &apos;gitalk.swig&apos; %&#125; 5.gitalk.styl新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容： 12345.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 6.third-party.styl修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式： 12@import &quot;gitalk&quot;; 7.修改_config.yml在主题配置文件next/_config.yml中添加如下内容： 123456789# Gitalkgitalk://这边一定要定格 enable: true clientID: &quot;xxxxxxxxxxxxxxxxx&quot; clientSecret: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; repo: &quot;myblog_comment&quot; owner: &quot;mengmayang&quot; admin: &quot;mengmayang&quot; distractionFreeMode: true 8.安装md51npm install md5 9.关于评论初始化和ERROR的问题 初始化需要mengmayang授权，所以每一篇博客的评论都需要自己进行初始化 目前长标题的博客会有Error: Validation Failed的问题，短标题则没有。 目前还没有解决的好办法，只能取短一点的标题喽~~ 参考https://www.jianshu.com/p/0bca03b43157 https://asdfv1929.github.io/2018/01/20/gitalk/ https://github.com/geedme/gitalk/issues/3 https://github.com/gitalk/gitalk/issues/115#event-1539518527 https://github.com/gitalk/gitalk/issues/102]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用gh-pages分支来在github中展示demo]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%88%A9%E7%94%A8gh-pages%E5%88%86%E6%94%AF%E6%9D%A5%E5%9C%A8github%E4%B8%AD%E5%B1%95%E7%A4%BAdemo%2F</url>
    <content type="text"><![CDATA[利用gh-pages 分支来在github中展示demo1.新建一个名为demo的仓库2.git clone到本地3.创建index.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;Demo of yyqiao&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 4.切换分支git checkout -b gh-pages 5.将master分支下的内容推送到远程gh-pages分支git push origin master:gh-pages *远程如果没有gh-pages分支会新创建 6.访问https://mengmayang.github.io/demo/ 亲测可行~~]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储基础知识一]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%2F</url>
    <content type="text"><![CDATA[存储基础知识一 块存储，文件存储，对象存储身为存储组的一员，如何能不了解存储，啃了几周的《大话存储》，虽然还是一知半解，但好歹对存储say hello了。比较重要的是块存储，文件存储和对象存储了哇，毕竟组内工作也是这么开展的，但读了培训资料还是觉得晦涩难懂，有必要系统梳理一下。 因为涉及到一些概念，故而需要对一些必要的知识有所了解 1. 几个基本概念RAID因为一块磁盘的容量和速度是有限的，对于一些特别大的数据，无论是存储还是读写速度，一块盘都不能满足。因此，RAID应运而生，Redundant Array of Independent Disks 有独立的磁盘组成的具有冗余特性的阵列。 RAID 将多个磁盘整合成逻辑上连续的存储区，经过RAID计算，可以再分成多个逻辑盘。 LVMLogical Volumn Management 卷管理层。对RAID控制器提交的逻辑盘加以组织再分配的软件。将OS识别到的磁盘逻辑上连续编址，再分割成小块，再组合成逻辑卷。像揉面团，哪里不够补一点。 FC 协议硬盘从内置主机到解放成独立设备，可以放在巨大的机柜里，通过并行SCSI总线与主机相连。但是通过SCSI总线连接的方式属于物理连接，一旦通信双方距离远就不合适了。面向无连接的FC交换网络代替并行SCSI总线是必然的。使存储系统和主机系统可以远隔千里进行通信。 使用FC协议，盘阵前端可以同时提供多个主机接口。同样，盘阵后端也采用FC协议，可以接入更加多的磁盘。 前端后端都采用FC协议实现网络化，意味着，一个个磁盘相当于网络上的节点，可以彻底实现网络化存储 DAS开放系统的直连式存储(Direct-Attached Storage），主机与存储设备之间采用SCSI连接。但随着磁盘阵列不断扩大，SCSI会成为IO瓶颈。 SAN存储区域网络（Storage Area Network）这个网络专门用来给主机连接存储设备用的，该网络中的元件都是为了让主机更好的访问存储设备。一般会采光纤来支持FC协议。 NAS网络附加存储（Network Attached Storage）指带有集中式文件系统功能的盘阵。将文件系统的功能迁移到磁盘阵列上，让磁盘自己管理存储空间。对外提供统一的用户接口，使用者不用再记录某某文件和券上扇区或者簇块的对应关系。 NAS与SAN的区别主要不是使用以太网和TCP/IP协议，而是，SAN是一个基于FC网络上的磁盘，NAS是一个以太网络上的文件系统。 网络文件系统与本地文件系统唯一的区别就是传输方式从主板上的导线变成了以太网络。 2. 块存储了解了以上概念，下面可以学习块存储、文件存储和对象存储了。 块存储主要就是将裸磁盘空间整个映射给主机使用。当然这个磁盘空间是通过RAID或者LVM划分出来的逻辑盘。与内置硬盘方式无异。 因为使用了RAID/LVM技术，对数据提供了保护，也提升了读写效率。通常块存储会采用SAN或者DAS架构组网，提升传输速度和读写速度；但是使用SAN架构组网时，通常涉及到FC协议，要买光纤交换机比较贵。 不做集群情况下，主机之间无法共享数据。不同操作系统的主机间也无法共享数据。 3. 文件存储为了克服主机之间无法共享的问题，有了文件存储。在NAS网络中，磁盘阵列上有一套集中式文件系统自己管理存储空间，不需要主机操作系统的参与，而主机与盘阵的集中式文件系统的交互通过网络来传递数据（以太网+TCP/IP）作为底层传输网络，而上层逻辑称为网络文件系统（相对于本地文件系统来讲）又名远程调用时文件系统RPC FS（Remote Procedure Call File System），微软的网络文件系统称为CIFS（Common Internet File System），Unix/Linux的称为NFS（Network File System）。这种文件系统逻辑不在本地运行而在网络上的其他节点运行。 这种存储方式不光磁盘和卷在远程节点，连文件系统也在远程节点。 *虽然FTP和NFS都属于文件存储，但是FTP是将远程文件先获取到本地再进行IO，不属于NAS 4. 对象存储相对于SAN和NAS两种主流网络存储架构的新的网络存储架构。基于对象存储技术的设备就是对象存储设备OSD（Object-based Storage Device） OBS（Object-Based Storage）对象存储综合了NAS和SAN的有点，同时具有SAN的高速直接访问和NAS的分布式数据共享的优势，高性能，高可靠性，跨平台以及安全的数据共享的存储体系结构。 为什么要搞对象存储？因为块存储虽然快，但是不能数据共享，文件存储可以共享文件，但是传输慢。 什么是OBS？多台服务器内置大容量硬盘，装上对象存储软件，在搞几台服务器作为管理节点，安装对象存储管理软件。管理节点可以管理其他服务器对外提供读写访问功能。 一个文件包含属性和内容属性：metadata，元数据，如文件大小，修改时间，存储路径内容：简称数据 文件系统的存储过程是先将文件打碎，然后一块一块的写进磁盘，不区分数据和metadata；对象存储将metadata独立出来，管理节点又叫元数据服务器（装有对象存储管理软件的服务器），主要负责对象的属性即metadata，其他负责存储数据的分布式服务器叫OSD，负责存储数据。用户先访问元数据服务器，了解到数据分布情况，再去相应的位置获取数据。由于是多台OSD同时对外传输数据，传输速度就加快了。 为什么有了对象存储还需要块存储和文件存储？数据库裸盘映射适合块存储对象存储需要对象存储软件和大容量硬盘，比起文件存储来讲还是比较贵的，如果数据量不大，只是为了实现数据共享，可以直接用文件存储。 总结三种存储方式不光依赖的传输方式不同，连存储设备本身也是不一样的，块存储设备磁盘阵列本身不集成文件管理系统；文件存储设备上会集成文件管理系统，并依赖网络文件管理系统；对象存储，除了依赖对象存储软件，对象存储管理软件，还对服务器集群进行了分类，负责管理的存元数据的服务器以及负责存储数据的OSD对象存储设备。 总的感觉就是存储设备本身负责的工作越来越多，越来越智能。 参考资料《大话存储》《SDS培训文档》]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识整理]]></title>
    <url>%2F2018%2F07%2F20%2FHTML%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTML 知识整理待更新。。。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCLinux安装教程新篇]]></title>
    <url>%2F2018%2F07%2F19%2FBCLinux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E6%96%B0%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本地虚拟机安装BC-Linux 新篇因为上一篇的描述过于简单，以至于有同学反应可读性比较差，而且关于NAT还是桥接的选择可能会遇到问题，故新篇以全图的方式来展示安装过程。 1. 开启虚拟支持这一步上一篇有讲win10如何开启虚拟支持，可以自行百度。 2. 安装BC-Linux 7.3主机开始虚拟支持之后，就可以开始安装虚拟机了 首先安装VMWare(也可以选择其他Virualbox等)，VMWare安装在主机上，虚拟机可以选择安装在硬盘上。 文件-&gt;新建虚拟机-&gt;自定义（高级） 下一步 下一步 下一步 选择位置，可选移动硬盘；给虚拟机起名字 选择处理器数量 分配内存，2G可以 默认使用NAT，如果需要主机浏览器查看虚拟机上apache目录选择桥接 下一步 下一步 创建新的虚拟磁盘 分配磁盘大小并存储为单个文件 命名磁盘文件 完成 选择CD/DVD-&gt;选择系统镜像BC-Linux-xxxx.iso 开机 开始安装，选择语言,安装过程可以申请root用户以及其他用户 可选我要配置分区，自定义分区 安装完成后重启 查看ip地址，如图25，未显示ip su root 切换管理员用户 修改/etc/sysconfig/network-scripts/ifcfg-ens33文件中的ONBOOT修改为yes 再次查看ip，172.20.5.209 可以ping 通主机了 ok！]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>软件</tag>
        <tag>linux</tag>
        <tag>BC-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell script]]></title>
    <url>%2F2018%2F07%2F12%2Fshell-script%2F</url>
    <content type="text"><![CDATA[写shell脚本1.交互式脚本read -p &quot;Please input your first name:&quot; firstname read -p &quot;Please input your last name:&quot; lastname echo -e &quot;\nYour full name is:&quot; $firstname $lastname 2.随日期变化read -p &quot;Please input your first name:&quot; firstuser filename=${fileuser:-&quot;filename&quot;} #当$fileuser没有设定或为控制，则用&quot;filename&quot;作为回传值 date1=$(date --date=&apos;2 days ago&apos; +%Y%m%d) #前两天的日期 date2=$(date --date=&apos;1 days ago&apos; +%Y%m%d) #前一天的日期 date3=$(date +%Y%m%d) #今天的日期 file1=${filename}${date1} file2=${filename}${date2} file3=${filename}${date3} touch &quot;file1&quot; touch &quot;file2&quot; touch &quot;file3&quot; 3.数值运算变量名=$((运算内容)) echo $((3*3)) 4.利用test进行测试test -e /dir &amp;&amp; echo &quot;exist&quot; || echo &quot;no exist&quot; #判断/dir是否存在 shell中的${}，##, %% , ：- ，：+， ？ 的使用假设我们定义了一个变量为： file=/dir1/dir2/dir3/my.file.txt 可以用${ }分别替换得到不同的值： ${file#*/}：删掉第一个/ 及其左边的字符串：dir1/dir2/dir3/my.file.txt ${file##*/}：删掉最后一个/ 及其左边的字符串：my.file.txt ${file#*.}：删掉第一个. 及其左边的字符串：file.txt ${file##*.}：删掉最后一个. 及其左边的字符串：txt ${file%/*}：删掉最后一个 / 及其右边的字符串：/dir1/dir2/dir3 ${file%%/*}：删掉第一个/ 及其右边的字符串：(空值) ${file%.*}：删掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file ${file%%.*}：删掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my 记忆的方法为： &apos;#&apos; 是 去掉左边（键盘上#在 $ 的左边） %是去掉右边（键盘上% 在$ 的右边） 单一符号是最小匹配；两个符号是最大匹配 ${file:0:5}：提取最左边的5 个字节：/dir1 ${file:5:5}：提取第5 个字节右边的连续5个字节：/dir2 也可以对变量值里的字符串作替换： ${file/dir/path}：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt ${file//dir/path}：将全部dir 替换为path：/path1/path2/path3/my.file.txt 利用${ } 还可针对不同的变数状态赋值(沒设定、空值、非空值)： ${file-my.file.txt} ：假如$file 沒有设定，則使用my.file.txt 作传回值。(空值及非空值時不作处理) ${file:-my.file.txt} ：假如$file 沒有設定或為空值，則使用my.file.txt 作傳回值。(非空值時不作处理) ${file+my.file.txt} ：假如$file 設為空值或非空值，均使用my.file.txt 作傳回值。(沒設定時不作处理) ${file:+my.file.txt} ：若$file 為非空值，則使用my.file.txt 作傳回值。(沒設定及空值時不作处理) ${file=my.file.txt} ：若$file 沒設定，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(空值及非空值時不作处理) ${file:=my.file.txt} ：若$file 沒設定或為空值，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(非空值時不作处理) ${file?my.file.txt} ：若$file 沒設定，則將my.file.txt 輸出至STDERR。(空值及非空值時不作处理) ${file:?my.file.txt} ：若$file 没设定或为空值，则将my.file.txt 输出至STDERR。(非空值時不作处理) ${#var} 可计算出变量值的长度： ${#file} 可得到27 ，因为/dir1/dir2/dir3/my.file.txt 是27个字节 5.条件判断式if [ 条件判断式 ]; then ... fi 如： if [ &quot;$Yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]; then echo &quot;OK&quot; exit 0 fi *中括号两边加空格，变量也要加双引号 if [ situation1 ]; then ... elif [ situation2 ]; then ... else ... fi ####实例练习 计算毕业时间 !/bin/bash # program: # You input your graduation date, I calculate how many days before you graduate. # History: # 2018/7/12 yyqiao 1.0 version #1. 输入说明 echo &quot;This program will try to calculate:&quot; echo &quot;How many days before your graduation date...&quot; read -p &quot;Please input your graduation data (YYYYMMDD ex&gt;20180712):&quot; date2 #2. 判断输入内容格式是否正确 date_d=$(echo $date2 | grep &apos;[0-9]\{8\}&apos;) #是否有8位数字 if [ &quot;$date_d&quot; == &quot;&quot; ]; then echo &quot;Wrong input&quot; exit 1 fi #3.计算日期 declare -i date_gra=`date --date=&quot;$date_d&quot; +%s` declare -i date_now=`date +%s` declare -i date_total=$(($date_gra-$date_now)) declare -i date_d=$(($date_total/60/60/24)) if [ &quot;$date_total&quot; -gt &quot;0&quot; ]; then declare -i date_h=$(($date_total-$date_d*60*60*24)/60/60) echo &quot;You will graduate after $date_d days and $date_h hours&quot; else echo &quot;You had been graduation before: &quot; $((-1*$date_d)) &quot; ago&quot; fi 6.function 功能function funName () { ... } 7.循环loopwhile [ condition ] do ... done until [ condition ] do ... done for var in con1 con2 con3 ... do ... done 如： for vari in $(seq 1 100) do ... done filelist =$(ls $dir) for file in filelist do ... done for ((初始值;限制值;执行步长)) do ... done 如： for(( i=1; i&lt;=9; i=i+1 )) do ... done 8.shell script 调试sh [-nvx] script.sh -n: 不要执行，仅检查语法 -v: 执行前先将script内容输出到屏幕上 -x: 将script显示在频幕上]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件格式化处理]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86-sed-awk%2F</url>
    <content type="text"><![CDATA[替换、删除、新增、提取特定行 分析关键字的使用，统计 sed 工具sed [-nefr] [动作] -n:经过sed处理的行被列出来 -e:命令行模式进行sed编辑 -f:直接将sed动作写在一个文件内，-f filename 可以执行filename中的sed动作 -r:sed动作支持扩展型正则表达式 -i:直接修改读取的文件内容，而非屏幕输出 动作： a:新增 c:替换 d:删除 i:插入 p:打印 s:替换（可搭配正则表达式） （1）以行为单位增加删除如： 列出并打印行号，同时删除2~5行 nl file | sed &apos;2,5d&apos; 列出并打印行号，同时删除3~最后一行 nl file | sed &apos;3,$d&apos; 第2行后面增加‘hello world’ nl file | sed &apos;2d, hello world&apos; 第2行前面增加‘hello world’ nl file | sed &apos;2i, hello world&apos; （2）以行为单位替换与显示如： 将2~5行内容替换成No 2-5 number nl file | sed &apos;2,5c No 2-5 number&apos; 列出5~7行 nl file | sed -n &apos;5,7p&apos; （3）部分数据的查找与替换sed &apos;s/要被替换的字符串/新的字符串/g&apos; 如：一行字符串为： intel addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 想要得到192.168.1.100，可以这样写 sed &apos;s/^.*addr://g&apos; | sed &apos;s/Bcast.*$//g&apos; 删掉空白行 sed &apos;/^$/d&apos; （4）直接修改文件内容（危险操作）如： 将每一行结尾的.替换成! sed -i &apos;s/\.$/!/g&apos; file 最后一行添加“This is a test” sed -i &apos;$a This is a test&apos; awk 工具词频统计 awk -F &apos;\t&apos; &apos;{count[$1]++}END{for(i in count){print i count[i]}}&apos; diff比较两个文件或者两个目录之间的差异 diff [-bBi] from-file to-file patch和diff配合使用，用于新旧版本更新]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装BC-Linux]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%AE%89%E8%A3%85BC-Linux%2F</url>
    <content type="text"><![CDATA[本地虚拟机安装BC-Linux1. 安装虚拟机我安装的是VMware 10，win10系统需要进入bios，开启虚拟支持 （1）win10 进入bios 开始-&gt;设置-&gt;更新和安全-&gt;恢复-&gt;高级启动（立即重新启动）-&gt;选择进入bios （2）bios开启虚拟支持 Security-&gt;Intel Virtual Technology 选择 Enabled F10 save and exit 2. 安装BC-Linux 7.3（1）下载系统镜像 http://mirrors.bclinux.org/bclinux/isos/BCLinux-R7-U3-Server-x86_64-dvd.iso （2）安装配置 硬盘设了150G 分区: /home:50G /:90G /boot:1G /swap:4G(一般为物理内存2倍) /var:4G (存放日志文件) 3. 重启4. 宿主机访问虚拟机（1）虚拟机网络连接方式选择桥接 （2）查看虚拟机的ip地址 （3）修改onboot vi /etc/sysconfig/network-scripts/ifcfg-ens33 （4）再次查看虚拟机的ip （5）查看网络是否通 （6）用putty等ssh到虚拟机的ip即可 以上的步骤是为了用ssh工具来访问虚拟机，因为VMWare的操作很不方便，接下来需要在宿主机的浏览器来访问虚拟机 5. 浏览器访问虚拟机服务器（1）增加源 在http://223.105.0.149/ 配置生成源信息 遇到问题 浏览器可以打开公网地址223.105.0.149，但是宿主机和虚拟机都ping不通，有可能是服务器防火墙限制了ping，解决方案，安装第三方源，见（2） （2）yum增加源 注意做备份 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache （3）开启apache并关闭防火墙 service httpd start service iptables stop （4）宿主机访问虚拟机的apache默认目录 172.20.19.151 虚拟机的ip是动态的，每次要查看一下，也可以设为静态的，比较方便 参考资料https://www.cnblogs.com/set-config/p/9040407.html https://blog.csdn.net/u010454030/article/details/78807281]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>软件</tag>
        <tag>linux</tag>
        <tag>BC-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 高级功能]]></title>
    <url>%2F2018%2F07%2F06%2Fvim-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[vim程序编辑器 高级功能1. 区块选择123456v:字符选择V:行选择Ctrl: 用长方形的方式选择资料y:复制p:粘贴d:删除 2. 多档案编辑这个功能牛逼啊！原来居然没有用过~~ 123456789101112:n - 编辑下一个文档:N - 编辑上一个文档:files - 列出目前这个vim开启的所有档案如：(1)vim test test1(2)4yy(3):n - 切换到下一个文件(4)G - 切换到最后一行(5)p - 粘贴(6)u - 按下多次u来还原原本的档案数据(7)wq 3. 多窗口功能我可能真的没有好好学习vim，牛逼的功能一个接着一个 情况一：文件很大，查阅后面的数据，想要对照前面的数据。是否需要使用ctrl+f和ctrl+b来前后查阅 情况二：有两个需要对照着看的文档，不想使用多档案编辑 能否将一个档案分割成多个窗口展现？ 1234567在指令模式输入:sp&#123;filename&#125;其中 不写filename表示将当前文件分成两个窗口，写filename表示两个窗口显示两个文件ctrl+w+j/↓ - 切换到下面的窗口ctrl+w+k/↑ - 切换到上面的窗口ctrl+w+q - 保存并离开 4. 环境设定与记录1~/.vimrc, ~/.viminfo 5. vim 环境参数123:set nu:nonu:set all 显示所有的环境参数设定值 6. vim 常用指令示意图]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新电脑安装工作软件]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%96%B0%E7%94%B5%E8%84%91%E5%AE%89%E8%A3%85%E5%B7%A5%E4%BD%9C%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[新电脑安装工作软件今天公司发了新电脑，开心之余又要展开安各种软件的繁琐过程，这里记录一下。 时间：2018/7/5基本配置 基本账户信息配置,安装网卡驱动 磁盘分区：D盘放置工作内容相关的文件 公司VPN软件安装及测试 安装软件以下是常用的办公软件，所以就安在办公的电脑上。 基础软件：Chrome/微信/360驱动大师/7-Zip/百度云/有道词典 编程软件：python(pip)/R(Rstudio) 工具软件：Git/XAMPP/nodejs(npm/cnpm)/gcc(cygwin)/putty/xshell 需要安装cpm的按照下面命令安装： 1npm install -g cnpm --registry=https://registry.npm.taobao.org C编译器系统从来不自带也是。。。mingw貌似需要翻墙，所以还是下载cygwin吧。cygwin默认不安装gcc，所以按照下面命令安装。 1C:\cygwin64&gt;setup-x86_64.exe -q -P wget -P gcc-g++ -P make -P diffutils -P libmpfr-devel -P libgmp-devel -P libmpc-devel 编辑器：sublimeText/MarkdownPad2/editplus 都需要注册码，我以前的不能用了，需要在网上重新找。MarkdownPad2 实时显示还需要下载awesomium 配置git 工作环境配置T470p的git密钥12345678git config --global user.name &quot;mengmayang&quot;git config --global user.email &quot;mengmayang@163.com&quot;ssh-keygen -t rsa （连着按3次entrer）cat ~/.ssh/id_rsa.pub 关于多电脑操做hexo+git管理blog记在本地了，就不放在网上了。 软件链接下载的所有软件放在新申请的百度云账号了，别和原来的混了。 就先记这样吧。。。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSSH隧道]]></title>
    <url>%2F2018%2F07%2F03%2FXSSH%E9%9A%A7%E9%81%93%2F</url>
    <content type="text"><![CDATA[Xshell 4 SSH隧道跳转访问局域网服务器为什么要用ssh隧道？ 通过公网访问局域网中的服务器 局域网中某些服务器或阵列提供Web管理界面，需要通过公网打开该管理界面 设想情景：我想在家用自己的浏览器打开公司局域网中的web服务器做coding，此时就需要将公司局域网中web服务器的端口映射到我自己的电脑的端口。 前提：局域网中有某台服务器接了公网（双网口，一个WAN，一个LAN）方法 假设一台局域网中的中转服务器A： 公网IP：58.64.173.79 局域网IP：192.168.1.99 通过服务器A来配置ssh隧道，将远程局域网中的服务器各个应用端口映射到本机端口，然后通过本机IP和端口去访问局域网中的其他服务器端口。 假设局域网中一台服务器B 局域网IP：192.168.1.78 服务器B配置了内部https端口443，我们可以将这个443端口映射到本机的某一个端口，然后在本机的这个端口打开https界面。 图一选中“中转服务器”这个session-&gt;右键-&gt;属性-&gt;隧道-&gt;添加-&gt;图二 打开浏览器，输入https://127.0.0.1:443(这个IP是本机IP，端口是图一中设置的本机 侦听端口，如果设置成其他的则改成相应的端口即可，等同于在局域网内登录https://192.168.1.78) 参考资料https://blog.csdn.net/jw2522/article/details/47065367]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 建立博客]]></title>
    <url>%2F2018%2F07%2F03%2FHexo-%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 建立个人博客比较重要的几条命令 1.本地测试1hexo server 2.部署到github上1hexo deploy -g -g 表示部署在remote之前先生成静态文件 3.新建md文件1hexo new "article_name" 4.建tags，categories，about123hexo new page tagshexo new page abouthexo new page categories 5.怎么插入图片首先将 _config.yml 中的post_asset_folder设为true 然后在根目录下执行1npm install https://github.com/CodeFalling/hexo-asset-image --save 之后把图片放在和文章名字一样的文件夹下 使用时 ![logo](文章名/logo.jpg) 其中[]里面不写文字则图片没有标题 6.修改网站图标将新图标放在/themes/next/source/images 修改next的主题配置文件: _config.yml 123favicon: small: /images/sheep.png medium:/images/sheep.png 参考资料https://blog.csdn.net/linshuhe1/article/details/52424573http://theme-next.iissnan.com/third-party-services.html#swfitype (gitbash 复制粘贴快捷键：Ctrl+ins/Shift+ins)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
