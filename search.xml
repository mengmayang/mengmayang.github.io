<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gitalk]]></title>
    <url>%2F2018%2F08%2F01%2Fgitalk%2F</url>
    <content type="text"><![CDATA[hexo + gitalk 给博客添加评论系统由于第三方评论系统基本全部扑街，所以不得不想其他对策，网上也有人提出搭建自己的第三方评论系统，但是需要自己有VPS呀，或者阿里云申请云主机？no，没钱！ 然后今天看到了gitalk，一个基于Github Issue和Preact 开发的评论插件。虽然还有一些小问题，但是从此我的博客有评论系统了，撒花~~ 详情Demo可见：https://gitalk.github.io/ 具体操作步骤如下： 1.申请github应用在GitHub上注册新应用，链接：https://github.com/settings/applications/new 参数说明：Application name： # 应用名称，随意Homepage URL： # 网站URL，如https://mengmayang.github.ioApplication description # 描述，随意Authorization callback URL：# 网站URL，https://mengmayang.github.io 然后你会得到Client ID和Client Secret 2.新增gitalk.swig新建/layout/_third-party/comments/gitalk.swig文件，并添加内容： {% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %} {% if theme.gitalk.enable %} {% if theme.gitalk.distractionFreeMode %} var gitalk = new Gitalk({ clientID: '{{theme.gitalk.clientID}}', clientSecret: '{{theme.gitalk.clientSecret}}', id: window.location.pathname, repo: '{{theme.gitalk.repo}}', owner: '{{theme.gitalk.owner}}', admin: '{{theme.gitalk.admin}}', distractionFreeMode: '{{theme.gitalk.distractionFreeMode}}', }) gitalk.render('gitalk-container') {% endif %} {% endif %} {% endif %} 3.comments.swig修改/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上： {% elseif theme.gitalk.enable %} &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; 我因为开启了disqus的count功能，所以disqus的enable是true，因此在增加gitalk的时候最后几行是： {% elseif theme.valine.appid and theme.valine.appkey %} &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;/div&gt; {% endif %} {% if theme.gitalk.distractionFreeMode %} {% endif %} {% endif %} //对应整体的if，也是文件末尾 4.index.swig修改layout/_third-party/comments/index.swig，在最后一行添加内容： {% include 'gitalk.swig' %} 5.gitalk.styl新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容： .gt-header a, .gt-comments a, .gt-popup a border-bottom: none; .gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 6.third-party.styl修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式： @import &quot;gitalk&quot;; 7.修改_config.yml在主题配置文件next/_config.yml中添加如下内容： # Gitalk gitalk://这边一定要定格 enable: true clientID: &quot;xxxxxxxxxxxxxxxxx&quot; clientSecret: &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; repo: &quot;myblog_comment&quot; owner: &quot;mengmayang&quot; admin: &quot;mengmayang&quot; distractionFreeMode: true 8.安装md5npm install md5 9.关于评论初始化和ERROR的问题 初始化需要mengmayang授权，所以每一篇博客的评论都需要自己进行初始化 目前长标题的博客会有Error: Validation Failed的问题，短标题则没有。 目前还没有解决的好办法，只能取短一点的标题喽~~ 参考https://www.jianshu.com/p/0bca03b43157 https://asdfv1929.github.io/2018/01/20/gitalk/ https://github.com/geedme/gitalk/issues/3 https://github.com/gitalk/gitalk/issues/115#event-1539518527 https://github.com/gitalk/gitalk/issues/102]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用gh-pages分支来在github中展示demo]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%88%A9%E7%94%A8gh-pages%E5%88%86%E6%94%AF%E6%9D%A5%E5%9C%A8github%E4%B8%AD%E5%B1%95%E7%A4%BAdemo%2F</url>
    <content type="text"><![CDATA[利用gh-pages 分支来在github中展示demo1.新建一个名为demo的仓库2.git clone到本地3.创建index.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;Demo of yyqiao&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 4.切换分支git checkout -b gh-pages 5.将master分支下的内容推送到远程gh-pages分支git push origin master:gh-pages *远程如果没有gh-pages分支会新创建 6.访问https://mengmayang.github.io/demo/ 亲测可行~~]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储基础知识一]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80%2F</url>
    <content type="text"><![CDATA[存储基础知识一 块存储，文件存储，对象存储身为存储组的一员，如何能不了解存储，啃了几周的《大话存储》，虽然还是一知半解，但好歹对存储say hello了。比较重要的是块存储，文件存储和对象存储了哇，毕竟组内工作也是这么开展的，但读了培训资料还是觉得晦涩难懂，有必要系统梳理一下。 因为涉及到一些概念，故而需要对一些必要的知识有所了解 1. 几个基本概念RAID因为一块磁盘的容量和速度是有限的，对于一些特别大的数据，无论是存储还是读写速度，一块盘都不能满足。因此，RAID应运而生，Redundant Array of Independent Disks 有独立的磁盘组成的具有冗余特性的阵列。 RAID 将多个磁盘整合成逻辑上连续的存储区，经过RAID计算，可以再分成多个逻辑盘。 LVMLogical Volumn Management 卷管理层。对RAID控制器提交的逻辑盘加以组织再分配的软件。将OS识别到的磁盘逻辑上连续编址，再分割成小块，再组合成逻辑卷。像揉面团，哪里不够补一点。 FC 协议硬盘从内置主机到解放成独立设备，可以放在巨大的机柜里，通过并行SCSI总线与主机相连。但是通过SCSI总线连接的方式属于物理连接，一旦通信双方距离远就不合适了。面向无连接的FC交换网络代替并行SCSI总线是必然的。使存储系统和主机系统可以远隔千里进行通信。 使用FC协议，盘阵前端可以同时提供多个主机接口。同样，盘阵后端也采用FC协议，可以接入更加多的磁盘。 前端后端都采用FC协议实现网络化，意味着，一个个磁盘相当于网络上的节点，可以彻底实现网络化存储 DAS开放系统的直连式存储(Direct-Attached Storage），主机与存储设备之间采用SCSI连接。但随着磁盘阵列不断扩大，SCSI会成为IO瓶颈。 SAN存储区域网络（Storage Area Network）这个网络专门用来给主机连接存储设备用的，该网络中的元件都是为了让主机更好的访问存储设备。一般会采光纤来支持FC协议。 NAS网络附加存储（Network Attached Storage）指带有集中式文件系统功能的盘阵。将文件系统的功能迁移到磁盘阵列上，让磁盘自己管理存储空间。对外提供统一的用户接口，使用者不用再记录某某文件和券上扇区或者簇块的对应关系。 NAS与SAN的区别主要不是使用以太网和TCP/IP协议，而是，SAN是一个基于FC网络上的磁盘，NAS是一个以太网络上的文件系统。 网络文件系统与本地文件系统唯一的区别就是传输方式从主板上的导线变成了以太网络。 2. 块存储了解了以上概念，下面可以学习块存储、文件存储和对象存储了。 块存储主要就是将裸磁盘空间整个映射给主机使用。当然这个磁盘空间是通过RAID或者LVM划分出来的逻辑盘。与内置硬盘方式无异。 因为使用了RAID/LVM技术，对数据提供了保护，也提升了读写效率。通常块存储会采用SAN或者DAS架构组网，提升传输速度和读写速度；但是使用SAN架构组网时，通常涉及到FC协议，要买光纤交换机比较贵。 不做集群情况下，主机之间无法共享数据。不同操作系统的主机间也无法共享数据。 3. 文件存储为了克服主机之间无法共享的问题，有了文件存储。在NAS网络中，磁盘阵列上有一套集中式文件系统自己管理存储空间，不需要主机操作系统的参与，而主机与盘阵的集中式文件系统的交互通过网络来传递数据（以太网+TCP/IP）作为底层传输网络，而上层逻辑称为网络文件系统（相对于本地文件系统来讲）又名远程调用时文件系统RPC FS（Remote Procedure Call File System），微软的网络文件系统称为CIFS（Common Internet File System），Unix/Linux的称为NFS（Network File System）。这种文件系统逻辑不在本地运行而在网络上的其他节点运行。 这种存储方式不光磁盘和卷在远程节点，连文件系统也在远程节点。 *虽然FTP和NFS都属于文件存储，但是FTP是将远程文件先获取到本地再进行IO，不属于NAS 4. 对象存储相对于SAN和NAS两种主流网络存储架构的新的网络存储架构。基于对象存储技术的设备就是对象存储设备OSD（Object-based Storage Device） OBS（Object-Based Storage）对象存储综合了NAS和SAN的有点，同时具有SAN的高速直接访问和NAS的分布式数据共享的优势，高性能，高可靠性，跨平台以及安全的数据共享的存储体系结构。 为什么要搞对象存储？因为块存储虽然快，但是不能数据共享，文件存储可以共享文件，但是传输慢。 什么是OBS？多台服务器内置大容量硬盘，装上对象存储软件，在搞几台服务器作为管理节点，安装对象存储管理软件。管理节点可以管理其他服务器对外提供读写访问功能。 一个文件包含属性和内容属性：metadata，元数据，如文件大小，修改时间，存储路径内容：简称数据 文件系统的存储过程是先将文件打碎，然后一块一块的写进磁盘，不区分数据和metadata；对象存储将metadata独立出来，管理节点又叫元数据服务器（装有对象存储管理软件的服务器），主要负责对象的属性即metadata，其他负责存储数据的分布式服务器叫OSD，负责存储数据。用户先访问元数据服务器，了解到数据分布情况，再去相应的位置获取数据。由于是多台OSD同时对外传输数据，传输速度就加快了。 为什么有了对象存储还需要块存储和文件存储？数据库裸盘映射适合块存储对象存储需要对象存储软件和大容量硬盘，比起文件存储来讲还是比较贵的，如果数据量不大，只是为了实现数据共享，可以直接用文件存储。 总结三种存储方式不光依赖的传输方式不同，连存储设备本身也是不一样的，块存储设备磁盘阵列本身不集成文件管理系统；文件存储设备上会集成文件管理系统，并依赖网络文件管理系统；对象存储，除了依赖对象存储软件，对象存储管理软件，还对服务器集群进行了分类，负责管理的存元数据的服务器以及负责存储数据的OSD对象存储设备。 总的感觉就是存储设备本身负责的工作越来越多，越来越智能。 参考资料《大话存储》《SDS培训文档》]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识整理]]></title>
    <url>%2F2018%2F07%2F20%2FHTML%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTML 知识整理待更新。。。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCLinux安装教程新篇]]></title>
    <url>%2F2018%2F07%2F19%2FBCLinux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E6%96%B0%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本地虚拟机安装BC-Linux 新篇因为上一篇的描述过于简单，以至于有同学反应可读性比较差，而且关于NAT还是桥接的选择可能会遇到问题，故新篇以全图的方式来展示安装过程。 1. 开启虚拟支持这一步上一篇有讲win10如何开启虚拟支持，可以自行百度。 2. 安装BC-Linux 7.3主机开始虚拟支持之后，就可以开始安装虚拟机了 首先安装VMWare(也可以选择其他Virualbox等)，VMWare安装在主机上，虚拟机可以选择安装在硬盘上。 文件-&gt;新建虚拟机-&gt;自定义（高级） 下一步 下一步 下一步 选择位置，可选移动硬盘；给虚拟机起名字 选择处理器数量 分配内存，2G可以 默认使用NAT，如果需要主机浏览器查看虚拟机上apache目录选择桥接 下一步 下一步 创建新的虚拟磁盘 分配磁盘大小并存储为单个文件 命名磁盘文件 完成 选择CD/DVD-&gt;选择系统镜像BC-Linux-xxxx.iso 开机 开始安装，选择语言,安装过程可以申请root用户以及其他用户 可选我要配置分区，自定义分区 安装完成后重启 查看ip地址，如图25，未显示ip su root 切换管理员用户 修改/etc/sysconfig/network-scripts/ifcfg-ens33文件中的ONBOOT修改为yes 再次查看ip，172.20.5.209 可以ping 通主机了 ok！]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>软件</tag>
        <tag>linux</tag>
        <tag>BC-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell script]]></title>
    <url>%2F2018%2F07%2F12%2Fshell-script%2F</url>
    <content type="text"><![CDATA[写shell脚本1.交互式脚本read -p &quot;Please input your first name:&quot; firstname read -p &quot;Please input your last name:&quot; lastname echo -e &quot;\nYour full name is:&quot; $firstname $lastname 2.随日期变化read -p &quot;Please input your first name:&quot; firstuser filename=${fileuser:-&quot;filename&quot;} #当$fileuser没有设定或为控制，则用&quot;filename&quot;作为回传值 date1=$(date --date=&apos;2 days ago&apos; +%Y%m%d) #前两天的日期 date2=$(date --date=&apos;1 days ago&apos; +%Y%m%d) #前一天的日期 date3=$(date +%Y%m%d) #今天的日期 file1=${filename}${date1} file2=${filename}${date2} file3=${filename}${date3} touch &quot;file1&quot; touch &quot;file2&quot; touch &quot;file3&quot; 3.数值运算变量名=$((运算内容)) echo $((3*3)) 4.利用test进行测试test -e /dir &amp;&amp; echo &quot;exist&quot; || echo &quot;no exist&quot; #判断/dir是否存在 shell中的${}，##, %% , ：- ，：+， ？ 的使用假设我们定义了一个变量为： file=/dir1/dir2/dir3/my.file.txt 可以用${ }分别替换得到不同的值： ${file#*/}：删掉第一个/ 及其左边的字符串：dir1/dir2/dir3/my.file.txt ${file##*/}：删掉最后一个/ 及其左边的字符串：my.file.txt ${file#*.}：删掉第一个. 及其左边的字符串：file.txt ${file##*.}：删掉最后一个. 及其左边的字符串：txt ${file%/*}：删掉最后一个 / 及其右边的字符串：/dir1/dir2/dir3 ${file%%/*}：删掉第一个/ 及其右边的字符串：(空值) ${file%.*}：删掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file ${file%%.*}：删掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my 记忆的方法为： &apos;#&apos; 是 去掉左边（键盘上#在 $ 的左边） %是去掉右边（键盘上% 在$ 的右边） 单一符号是最小匹配；两个符号是最大匹配 ${file:0:5}：提取最左边的5 个字节：/dir1 ${file:5:5}：提取第5 个字节右边的连续5个字节：/dir2 也可以对变量值里的字符串作替换： ${file/dir/path}：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt ${file//dir/path}：将全部dir 替换为path：/path1/path2/path3/my.file.txt 利用${ } 还可针对不同的变数状态赋值(沒设定、空值、非空值)： ${file-my.file.txt} ：假如$file 沒有设定，則使用my.file.txt 作传回值。(空值及非空值時不作处理) ${file:-my.file.txt} ：假如$file 沒有設定或為空值，則使用my.file.txt 作傳回值。(非空值時不作处理) ${file+my.file.txt} ：假如$file 設為空值或非空值，均使用my.file.txt 作傳回值。(沒設定時不作处理) ${file:+my.file.txt} ：若$file 為非空值，則使用my.file.txt 作傳回值。(沒設定及空值時不作处理) ${file=my.file.txt} ：若$file 沒設定，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(空值及非空值時不作处理) ${file:=my.file.txt} ：若$file 沒設定或為空值，則使用my.file.txt 作傳回值，同時將$file 賦值為my.file.txt 。(非空值時不作处理) ${file?my.file.txt} ：若$file 沒設定，則將my.file.txt 輸出至STDERR。(空值及非空值時不作处理) ${file:?my.file.txt} ：若$file 没设定或为空值，则将my.file.txt 输出至STDERR。(非空值時不作处理) ${#var} 可计算出变量值的长度： ${#file} 可得到27 ，因为/dir1/dir2/dir3/my.file.txt 是27个字节 5.条件判断式if [ 条件判断式 ]; then ... fi 如： if [ &quot;$Yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]; then echo &quot;OK&quot; exit 0 fi *中括号两边加空格，变量也要加双引号 if [ situation1 ]; then ... elif [ situation2 ]; then ... else ... fi ####实例练习 计算毕业时间 !/bin/bash # program: # You input your graduation date, I calculate how many days before you graduate. # History: # 2018/7/12 yyqiao 1.0 version #1. 输入说明 echo &quot;This program will try to calculate:&quot; echo &quot;How many days before your graduation date...&quot; read -p &quot;Please input your graduation data (YYYYMMDD ex&gt;20180712):&quot; date2 #2. 判断输入内容格式是否正确 date_d=$(echo $date2 | grep &apos;[0-9]\{8\}&apos;) #是否有8位数字 if [ &quot;$date_d&quot; == &quot;&quot; ]; then echo &quot;Wrong input&quot; exit 1 fi #3.计算日期 declare -i date_gra=`date --date=&quot;$date_d&quot; +%s` declare -i date_now=`date +%s` declare -i date_total=$(($date_gra-$date_now)) declare -i date_d=$(($date_total/60/60/24)) if [ &quot;$date_total&quot; -gt &quot;0&quot; ]; then declare -i date_h=$(($date_total-$date_d*60*60*24)/60/60) echo &quot;You will graduate after $date_d days and $date_h hours&quot; else echo &quot;You had been graduation before: &quot; $((-1*$date_d)) &quot; ago&quot; fi 6.function 功能function funName () { ... } 7.循环loopwhile [ condition ] do ... done until [ condition ] do ... done for var in con1 con2 con3 ... do ... done 如： for vari in $(seq 1 100) do ... done filelist =$(ls $dir) for file in filelist do ... done for ((初始值;限制值;执行步长)) do ... done 如： for(( i=1; i&lt;=9; i=i+1 )) do ... done 8.shell script 调试sh [-nvx] script.sh -n: 不要执行，仅检查语法 -v: 执行前先将script内容输出到屏幕上 -x: 将script显示在频幕上]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件格式化处理]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86-sed-awk%2F</url>
    <content type="text"><![CDATA[替换、删除、新增、提取特定行 分析关键字的使用，统计 sed 工具sed [-nefr] [动作] -n:经过sed处理的行被列出来 -e:命令行模式进行sed编辑 -f:直接将sed动作写在一个文件内，-f filename 可以执行filename中的sed动作 -r:sed动作支持扩展型正则表达式 -i:直接修改读取的文件内容，而非屏幕输出 动作： a:新增 c:替换 d:删除 i:插入 p:打印 s:替换（可搭配正则表达式） （1）以行为单位增加删除如： 列出并打印行号，同时删除2~5行 nl file | sed &apos;2,5d&apos; 列出并打印行号，同时删除3~最后一行 nl file | sed &apos;3,$d&apos; 第2行后面增加‘hello world’ nl file | sed &apos;2d, hello world&apos; 第2行前面增加‘hello world’ nl file | sed &apos;2i, hello world&apos; （2）以行为单位替换与显示如： 将2~5行内容替换成No 2-5 number nl file | sed &apos;2,5c No 2-5 number&apos; 列出5~7行 nl file | sed -n &apos;5,7p&apos; （3）部分数据的查找与替换sed &apos;s/要被替换的字符串/新的字符串/g&apos; 如：一行字符串为： intel addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 想要得到192.168.1.100，可以这样写 sed &apos;s/^.*addr://g&apos; | sed &apos;s/Bcast.*$//g&apos; 删掉空白行 sed &apos;/^$/d&apos; （4）直接修改文件内容（危险操作）如： 将每一行结尾的.替换成! sed -i &apos;s/\.$/!/g&apos; file 最后一行添加“This is a test” sed -i &apos;$a This is a test&apos; awk 工具词频统计 awk -F &apos;\t&apos; &apos;{count[$1]++}END{for(i in count){print i count[i]}}&apos; diff比较两个文件或者两个目录之间的差异 diff [-bBi] from-file to-file patch和diff配合使用，用于新旧版本更新]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装BC-Linux]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%AE%89%E8%A3%85BC-Linux%2F</url>
    <content type="text"><![CDATA[本地虚拟机安装BC-Linux1. 安装虚拟机我安装的是VMware 10，win10系统需要进入bios，开启虚拟支持 （1）win10 进入bios 开始-&gt;设置-&gt;更新和安全-&gt;恢复-&gt;高级启动（立即重新启动）-&gt;选择进入bios （2）bios开启虚拟支持 Security-&gt;Intel Virtual Technology 选择 Enabled F10 save and exit 2. 安装BC-Linux 7.3（1）下载系统镜像 http://mirrors.bclinux.org/bclinux/isos/BCLinux-R7-U3-Server-x86_64-dvd.iso （2）安装配置 硬盘设了150G 分区: /home:50G /:90G /boot:1G /swap:4G(一般为物理内存2倍) /var:4G (存放日志文件) 3. 重启4. 宿主机访问虚拟机（1）虚拟机网络连接方式选择桥接 （2）查看虚拟机的ip地址 （3）修改onboot vi /etc/sysconfig/network-scripts/ifcfg-ens33 （4）再次查看虚拟机的ip （5）查看网络是否通 （6）用putty等ssh到虚拟机的ip即可 以上的步骤是为了用ssh工具来访问虚拟机，因为VMWare的操作很不方便，接下来需要在宿主机的浏览器来访问虚拟机 5. 浏览器访问虚拟机服务器（1）增加源 在http://223.105.0.149/ 配置生成源信息 遇到问题 浏览器可以打开公网地址223.105.0.149，但是宿主机和虚拟机都ping不通，有可能是服务器防火墙限制了ping，解决方案，安装第三方源，见（2） （2）yum增加源 注意做备份 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache （3）开启apache并关闭防火墙 service httpd start service iptables stop （4）宿主机访问虚拟机的apache默认目录 172.20.19.151 虚拟机的ip是动态的，每次要查看一下，也可以设为静态的，比较方便 参考资料https://www.cnblogs.com/set-config/p/9040407.html https://blog.csdn.net/u010454030/article/details/78807281]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>软件</tag>
        <tag>linux</tag>
        <tag>BC-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 高级功能]]></title>
    <url>%2F2018%2F07%2F06%2Fvim-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[vim程序编辑器 高级功能1. 区块选择123456v:字符选择V:行选择Ctrl: 用长方形的方式选择资料y:复制p:粘贴d:删除 2. 多档案编辑这个功能牛逼啊！原来居然没有用过~~ 123456789101112:n - 编辑下一个文档:N - 编辑上一个文档:files - 列出目前这个vim开启的所有档案如：(1)vim test test1(2)4yy(3):n - 切换到下一个文件(4)G - 切换到最后一行(5)p - 粘贴(6)u - 按下多次u来还原原本的档案数据(7)wq 3. 多窗口功能我可能真的没有好好学习vim，牛逼的功能一个接着一个 情况一：文件很大，查阅后面的数据，想要对照前面的数据。是否需要使用ctrl+f和ctrl+b来前后查阅 情况二：有两个需要对照着看的文档，不想使用多档案编辑 能否将一个档案分割成多个窗口展现？ 1234567在指令模式输入:sp&#123;filename&#125;其中 不写filename表示将当前文件分成两个窗口，写filename表示两个窗口显示两个文件ctrl+w+j/↓ - 切换到下面的窗口ctrl+w+k/↑ - 切换到上面的窗口ctrl+w+q - 保存并离开 4. 环境设定与记录1~/.vimrc, ~/.viminfo 5. vim 环境参数123:set nu:nonu:set all 显示所有的环境参数设定值 6. vim 常用指令示意图]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新电脑安装工作软件]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%96%B0%E7%94%B5%E8%84%91%E5%AE%89%E8%A3%85%E5%B7%A5%E4%BD%9C%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[新电脑安装工作软件今天公司发了新电脑，开心之余又要展开安各种软件的繁琐过程，这里记录一下。 时间：2018/7/5基本配置 基本账户信息配置,安装网卡驱动 磁盘分区：D盘放置工作内容相关的文件 公司VPN软件安装及测试 安装软件以下是常用的办公软件，所以就安在办公的电脑上。 基础软件：Chrome/微信/360驱动大师/7-Zip/百度云/有道词典 编程软件：python(pip)/R(Rstudio) 工具软件：Git/XAMPP/nodejs(npm/cnpm)/gcc(cygwin)/putty/xshell 需要安装cpm的按照下面命令安装： 1npm install -g cnpm --registry=https://registry.npm.taobao.org C编译器系统从来不自带也是。。。mingw貌似需要翻墙，所以还是下载cygwin吧。cygwin默认不安装gcc，所以按照下面命令安装。 1C:\cygwin64&gt;setup-x86_64.exe -q -P wget -P gcc-g++ -P make -P diffutils -P libmpfr-devel -P libgmp-devel -P libmpc-devel 编辑器：sublimeText/MarkdownPad2/editplus 都需要注册码，我以前的不能用了，需要在网上重新找。MarkdownPad2 实时显示还需要下载awesomium 配置git 工作环境配置T470p的git密钥12345678git config --global user.name &quot;mengmayang&quot;git config --global user.email &quot;mengmayang@163.com&quot;ssh-keygen -t rsa （连着按3次entrer）cat ~/.ssh/id_rsa.pub 关于多电脑操做hexo+git管理blog记在本地了，就不放在网上了。 软件链接下载的所有软件放在新申请的百度云账号了，别和原来的混了。 就先记这样吧。。。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to RunningSheep’s blog! This is my first blog. I wish to use this blog to record my experience when learning the front-end knowledge and something interesting in my life.]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSSH隧道]]></title>
    <url>%2F2018%2F07%2F03%2FXSSH%E9%9A%A7%E9%81%93%2F</url>
    <content type="text"><![CDATA[Xshell 4 SSH隧道跳转访问局域网服务器为什么要用ssh隧道？ 通过公网访问局域网中的服务器 局域网中某些服务器或阵列提供Web管理界面，需要通过公网打开该管理界面 设想情景：我想在家用自己的浏览器打开公司局域网中的web服务器做coding，此时就需要将公司局域网中web服务器的端口映射到我自己的电脑的端口。 前提：局域网中有某台服务器接了公网（双网口，一个WAN，一个LAN）方法 假设一台局域网中的中转服务器A： 公网IP：58.64.173.79 局域网IP：192.168.1.99 通过服务器A来配置ssh隧道，将远程局域网中的服务器各个应用端口映射到本机端口，然后通过本机IP和端口去访问局域网中的其他服务器端口。 假设局域网中一台服务器B 局域网IP：192.168.1.78 服务器B配置了内部https端口443，我们可以将这个443端口映射到本机的某一个端口，然后在本机的这个端口打开https界面。 图一选中“中转服务器”这个session-&gt;右键-&gt;属性-&gt;隧道-&gt;添加-&gt;图二 打开浏览器，输入https://127.0.0.1:443(这个IP是本机IP，端口是图一中设置的本机 侦听端口，如果设置成其他的则改成相应的端口即可，等同于在局域网内登录https://192.168.1.78) 参考资料https://blog.csdn.net/jw2522/article/details/47065367]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 建立博客]]></title>
    <url>%2F2018%2F07%2F03%2FHexo-%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 建立个人博客比较重要的几条命令 1.本地测试1hexo server 2.部署到github上1234567hexo deploy -gorhexo cleanhexo generatehexo deploy -g 表示部署在remote之前先生成静态文件 3.新建md文件1hexo new "article_name" 4.建tags，categories，about123hexo new page tagshexo new page abouthexo new page categories 5.怎么插入图片首先将 _config.yml 中的post_asset_folder设为true 然后在根目录下执行1npm install https://github.com/CodeFalling/hexo-asset-image --save 之后把图片放在和文章名字一样的文件夹下 使用时 ![logo](文章名/logo.jpg) 其中[]里面不写文字则图片没有标题 6.修改网站图标将新图标放在/themes/next/source/images 修改next的主题配置文件: _config.yml 123favicon: small: /images/sheep.png medium:/images/sheep.png 参考资料https://blog.csdn.net/linshuhe1/article/details/52424573http://theme-next.iissnan.com/third-party-services.html#swfitype (gitbash 复制粘贴快捷键：Ctrl+ins/Shift+ins)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
